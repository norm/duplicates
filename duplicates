#!/usr/bin/env perl

use Modern::Perl '2012';
use Digest::SHA1;
use File::Next;
use FileHandle;
use Redis;
use Try::Tiny;

use constant NAMESPACE => 'duplicates';
use constant SET_KEY   => sprintf '%s:%s', NAMESPACE, 'all';

$| = 1;
my $redis = Redis->new();
my $verbose = 0;

my $arg = shift;
die unless defined $arg;

scan_directory( @ARGV )
    if 'scan' eq $arg;
list_all_duplicates( @ARGV )
    if 'list' eq $arg;
list_matches( @ARGV )
    if 'matches' eq $arg;
delete_duplicates( @ARGV )
    if 'delete' eq $arg;
rescan_duplicates()
    if 'rescan' eq $arg;
exit;



sub scan_directory {
    my $directory = shift;

    my $files = File::Next::files( $directory );
    while( my $file = $files->() ) {
        say $file
            if $verbose;

        try {
            my $digest = get_sha_of_file( $file );
            register_file( $file, $digest );
        }
        catch {
            warn "$file: $!";
        };

        print '.'
            if not $verbose;
    }
    say ''
        if not $verbose;
}
sub list_all_duplicates {
    my @directories = $@;

    my @duplicates = $redis->zrevrangebyscore( SET_KEY, '+inf', 2 );
    foreach my $dupe ( @duplicates ) {
        $dupe =~ m{:(.*)};
        say "${1}:";
        foreach my $key ( $redis->hkeys( $dupe ) ) {
            say "    $key";
        }
        say '';
    }
}
sub list_matches {
    my @list = @_;

    foreach my $item ( @list ) {
        say "${item}:";

        my @matches = get_matching_files( $item );
        foreach my $match ( @matches ) {
            say "    $match"
                unless $match eq $item;
        }

        say '';
    }
}
sub delete_duplicates {
    my @list = @_;

    foreach my $directory ( @list ) {
        my $files = File::Next::files( $directory );
        while( my $file = $files->() ) {
            my $digest  = get_sha_of_file( $file );
            my @matches = get_matching_files( $file );
            
            # only delete it if other duplicates exist
            next unless $#matches;

            # double check those duplicates still exist
            foreach my $match ( @matches ) {
                next if $match eq $file;
                
                my $match_digest = get_sha_of_file( $match );
                next unless defined $match_digest
                            and $match_digest eq $digest;

                unlink $file
                    or die "Couldn't delete $file: $!";

                deregister_file( $file, $digest );
                say "Deleted $file"
                    if $verbose;
                last;
            }
        }
    }
}
sub rescan_duplicates {
    my @duplicates = $redis->zrevrangebyscore( SET_KEY, '+inf', 1 );

    foreach my $duplicate ( @duplicates ) {
        $duplicate =~ m{:(.*)};
        my $orig_digest = $1;

        foreach my $file ( $redis->hkeys( $duplicate ) ) {
            my $digest = get_sha_of_file( $file ) // '';
            if ( $orig_digest ne $digest ) {
                say "Updating $file";
                deregister_file( $file, $orig_digest );
                register_file( $file, $digest )
                    if $digest;
            }
        }
    }
}

sub get_matching_files {
    my $file = shift;

    my $digest  = get_sha_of_file( $file );
    my $key     = sprintf '%s:%s', NAMESPACE, $digest;

    return $redis->hkeys( $key );
}
sub get_sha_of_file {
    my $file = shift;

    my $handle = FileHandle->new( $file );
    return unless defined $handle;

    my $sha = Digest::SHA1->new();
    $sha->addfile( $handle );

    return $sha->hexdigest;
}

sub register_file {
    my $file   = shift;
    my $digest = shift;

    my $key = sprintf '%s:%s', NAMESPACE, $digest;
    $redis->hset( $key, $file, 1 );

    my $count = $redis->hlen( $key );
    $redis->zadd( SET_KEY, $count, $key );
}
sub deregister_file {
    my $file   = shift;
    my $digest = shift;

    my $key = sprintf '%s:%s', NAMESPACE, $digest;
    $redis->hdel( $key, $file );

    my $count = $redis->hlen( $key );
    $redis->zadd( SET_KEY, $count, $key );
}