#!/usr/bin/env perl

use Modern::Perl '2012';
use Digest::SHA1;
use File::Next;
use FileHandle;
use Redis;
use Try::Tiny;

use constant NAMESPACE => 'duplicates';
use constant SET_KEY   => sprintf '%s:%s', NAMESPACE, 'all';

$| = 1;
my $redis = Redis->new();
my $verbose = 0;

my $arg = shift;
die unless defined $arg;

scan_directory( @ARGV )
    if 'scan' eq $arg;
list_all_duplicates( @ARGV )
    if 'list' eq $arg;
list_matches( @ARGV )
    if 'matches' eq $arg;
exit;



sub scan_directory {
    my $directory = shift;

    my $files = File::Next::files( $directory );
    while( my $file = $files->() ) {
        say $file
            if $verbose;

        try {
            my $digest = get_sha_of_file( $file );
            my $key    = sprintf '%s:%s', NAMESPACE, $digest;
            $redis->hset( $key, $file, 1 );

            my $count = $redis->hlen( $key );
            $redis->zadd( SET_KEY, $count, $key );
        }
        catch {
            warn "$file: $!";
        };

        print '.'
            if not $verbose;
    }
    say ''
        if not $verbose;
}
sub list_all_duplicates {
    my @directories = $@;

    my @duplicates = $redis->zrevrangebyscore( SET_KEY, '+inf', 2 );
    foreach my $dupe ( @duplicates ) {
        $dupe =~ m{:(.*)};
        say "${1}:";
        foreach my $key ( $redis->hkeys( $dupe ) ) {
            say "    $key";
        }
        say '';
    }
}
sub list_matches {
    my @list = @_;

    foreach my $item ( @list ) {
        say "${item}:";

        my $digest  = get_sha_of_file( $item );
        my $key     = sprintf '%s:%s', NAMESPACE, $digest;
        my @matches = $redis->hkeys( $key );

        foreach my $match ( @matches ) {
            say "    $match"
                unless $match eq $item;
        }

        say '';
    }
}

sub get_sha_of_file {
    my $file = shift;

    my $handle = FileHandle->new( $file );
    my $sha    = Digest::SHA1->new();
    $sha->addfile( $handle );

    return $sha->hexdigest;
}
